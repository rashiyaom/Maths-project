<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Cat's Quest: A Logic Adventure</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Gaegu:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Gaegu', cursive;
        }
        .vignette {
            box-shadow: inset 0 0 100px rgba(0,0,0,0.4);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes slideInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
        .slide-in-up {
            animation: slideInUp 0.5s ease-out forwards;
        }
        .symbol-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            padding: 1rem;
            transition: transform 0.2s ease, background 0.2s ease;
        }
        .symbol-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body class="bg-gray-800 text-white flex items-center justify-center min-h-screen p-4">

    <!-- Level Selection Screen -->
    <div id="level-selection" class="w-full max-w-4xl bg-gray-900 rounded-2xl shadow-2xl p-6 md:p-8 border-4 border-gray-700 text-center fade-in">
        <h1 class="text-4xl md:text-5xl font-bold text-amber-400 mb-6">Choose Your Adventure!</h1>
        <p class="text-lg text-gray-300 mb-8">Select the type of challenge you want to face:</p>
        
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <!-- Cat Food Level -->
            <div class="bg-gradient-to-br from-orange-500 to-amber-600 rounded-xl p-6 cursor-pointer transform hover:scale-105 transition-all duration-300 shadow-lg" id="food-level-btn">
                <div class="text-6xl mb-4">üê±üçΩÔ∏è</div>
                <h2 class="text-2xl font-bold text-white mb-3">Cat Food Quest</h2>
                <p class="text-white/90 mb-3 text-sm">Help a hungry cat navigate urban challenges to reach its delicious meal!</p>
                <div class="bg-white/20 rounded-lg p-2">
                    <p class="text-xs text-white"><strong>5 Stages</strong> ‚Ä¢ Urban Adventure</p>
                </div>
            </div>

            <!-- Medical Level -->
            <div class="bg-gradient-to-br from-red-500 to-pink-600 rounded-xl p-6 cursor-pointer transform hover:scale-105 transition-all duration-300 shadow-lg" id="medical-level-btn">
                <div class="text-6xl mb-4">üè•‚öïÔ∏è</div>
                <h2 class="text-2xl font-bold text-white mb-3">Dr. Cat's Hospital</h2>
                <p class="text-white/90 mb-3 text-sm">Play as Dr. Cat, a skilled surgeon performing life-saving operations!</p>
                <div class="bg-white/20 rounded-lg p-2">
                    <p class="text-xs text-white"><strong>10 Stages</strong> ‚Ä¢ Medical Operations</p>
                </div>
            </div>

            <!-- Military Level -->
            <div class="bg-gradient-to-br from-green-600 to-emerald-700 rounded-xl p-6 cursor-pointer transform hover:scale-105 transition-all duration-300 shadow-lg" id="military-level-btn">
                <div class="text-6xl mb-4">ü™ñ‚öîÔ∏è</div>
                <h2 class="text-2xl font-bold text-white mb-3">Colonel Cat's War</h2>
                <p class="text-white/90 mb-3 text-sm">Lead as Colonel Cat through strategic military operations and tactical decisions!</p>
                <div class="bg-white/20 rounded-lg p-2">
                    <p class="text-xs text-white"><strong>10 Stages</strong> ‚Ä¢ Military Strategy</p>
                </div>
            </div>
        </div>
        
        <!-- Instructions -->
        <div class="mt-8 text-left bg-gray-800 p-6 rounded-lg border border-gray-700">
            <h2 class="text-2xl font-bold text-amber-300 mb-4">How to Play</h2>
            <p class="mb-2">In each stage, you will be presented with a scenario and a <strong class="text-white">Logical Rule</strong>.</p>
            <p class="mb-4">Choose the one option that correctly follows the rule to advance and earn <strong class="text-white">10 points</strong>. A wrong choice will deduct points!</p>

            <h3 class="text-xl font-bold text-amber-300 mt-6 mb-4">Understanding the Logic</h3>
            <p class="mb-4">These symbols represent different types of logical statements:</p>
            <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                <div class="symbol-card">
                    <p class="text-3xl font-mono text-cyan-400">P ‚Üí Q</p>
                    <p class="mt-2"><strong>THEN (Conditional)</strong></p>
                    <p class="text-sm text-gray-400">If P is true, then Q must be true.</p>
                </div>
                <div class="symbol-card">
                    <p class="text-3xl font-mono text-cyan-400">P ‚Üî Q</p>
                    <p class="mt-2"><strong>IF AND ONLY IF</strong></p>
                    <p class="text-sm text-gray-400">P is true only when Q is true, and vice-versa.</p>
                </div>
                <div class="symbol-card">
                    <p class="text-3xl font-mono text-cyan-400">¬¨P</p>
                    <p class="mt-2"><strong>NOT (Negation)</strong></p>
                    <p class="text-sm text-gray-400">The opposite of P.</p>
                </div>
                <div class="symbol-card">
                    <p class="text-3xl font-mono text-cyan-400">P ‚àß Q</p>
                    <p class="mt-2"><strong>AND (Conjunction)</strong></p>
                    <p class="text-sm text-gray-400">Both P and Q must be true.</p>
                </div>
                <div class="symbol-card">
                    <p class="text-3xl font-mono text-cyan-400">P ‚à® Q</p>
                    <p class="mt-2"><strong>OR (Disjunction)</strong></p>
                    <p class="text-sm text-gray-400">Either P is true, or Q is true, or both.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Container -->
    <div id="game-container" class="w-full max-w-2xl bg-gray-900 rounded-2xl shadow-2xl p-6 md:p-8 border-4 border-gray-700 text-center hidden">
        <div class="relative mb-4">
            <h1 id="game-title" class="text-4xl md:text-5xl font-bold text-amber-400">The Cat's Quest</h1>
            <div class="flex justify-between items-center mt-2">
                <div id="level-indicator" class="bg-blue-600 text-white font-bold px-3 py-1 rounded-lg text-sm">Food Quest</div>
                <div id="score-display" class="bg-amber-400 text-gray-900 font-bold px-4 py-2 rounded-lg text-xl">Score: 0</div>
            </div>
        </div>

        <!-- Conditional Statement Clue -->
        <div id="logic-clue-container" class="bg-amber-100 border-2 border-dashed border-amber-400 text-amber-900 rounded-lg p-4 mb-6 hidden">
            <p class="font-bold text-lg">Logical Rule:</p>
            <p id="logic-clue-text" class="text-lg"></p>
            <p id="logic-clue-symbolic" class="text-2xl font-mono mt-2"></p>
        </div>
        
        <!-- Dynamic Content Area -->
        <div id="scenario" class="bg-gray-800 rounded-lg p-6 mb-6 vignette border border-gray-700 min-h-[250px] flex flex-col items-center justify-center">
            <div id="scenario-image" class="text-6xl mb-4"></div>
            <p id="scenario-text" class="text-xl md:text-2xl text-gray-200"></p>
        </div>

        <!-- Options -->
        <div id="options-container" class="grid grid-cols-1 md:grid-cols-3 gap-4"></div>

        <!-- Feedback Message -->
        <div id="feedback-container" class="mt-6 text-2xl font-bold hidden">
            <p id="feedback-text"></p>
            <div class="flex justify-center items-center gap-4 mt-4 flex-wrap">
                <button id="next-button" class="px-8 py-3 bg-green-600 hover:bg-green-700 rounded-lg shadow-lg transform hover:scale-105 transition-transform">Next</button>
                <button id="restart-button" class="px-8 py-3 bg-red-600 hover:bg-red-700 rounded-lg shadow-lg transform hover:scale-105 transition-transform hidden">Try Again</button>
                <button id="bonus-level-button" class="px-8 py-3 bg-purple-600 hover:bg-purple-700 rounded-lg shadow-lg transform hover:scale-105 transition-transform hidden">‚ú® Generate Bonus Level</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== LOGIC EVALUATION ENGINE ====================
        
        /**
         * Logic Evaluation Engine - Core system for parsing and evaluating logical statements
         * Supports: AND (‚àß), OR (‚à®), NOT (¬¨), IMPLIES (‚Üí), BICONDITIONAL (‚Üî)
         */
        class LogicEngine {
            constructor() {
                this.operators = {
                    '‚àß': { precedence: 3, associativity: 'left', type: 'binary' },
                    'AND': { precedence: 3, associativity: 'left', type: 'binary' },
                    '‚à®': { precedence: 2, associativity: 'left', type: 'binary' },
                    'OR': { precedence: 2, associativity: 'left', type: 'binary' },
                    '‚Üí': { precedence: 1, associativity: 'right', type: 'binary' },
                    'IMPLIES': { precedence: 1, associativity: 'right', type: 'binary' },
                    '‚Üî': { precedence: 1, associativity: 'left', type: 'binary' },
                    'BICONDITIONAL': { precedence: 1, associativity: 'left', type: 'binary' },
                    '¬¨': { precedence: 4, associativity: 'right', type: 'unary' },
                    'NOT': { precedence: 4, associativity: 'right', type: 'unary' }
                };
            }

            /**
             * Tokenize a logical expression into components
             * @param {string} expression - The logical expression to tokenize
             * @returns {Array} Array of tokens
             */
            tokenize(expression) {
                // Replace symbolic operators with word equivalents for easier parsing
                const normalizedExpr = expression
                    .replace(/‚àß/g, ' AND ')
                    .replace(/‚à®/g, ' OR ')
                    .replace(/‚Üí/g, ' IMPLIES ')
                    .replace(/‚Üî/g, ' BICONDITIONAL ')
                    .replace(/¬¨/g, ' NOT ')
                    .replace(/\(/g, ' ( ')
                    .replace(/\)/g, ' ) ');

                const tokens = normalizedExpr
                    .split(/\s+/)
                    .filter(token => token.trim() !== '');

                return tokens;
            }

            /**
             * Convert infix notation to postfix (Reverse Polish Notation) using Shunting Yard algorithm
             * @param {Array} tokens - Array of tokens in infix notation
             * @returns {Array} Array of tokens in postfix notation
             */
            infixToPostfix(tokens) {
                const output = [];
                const operatorStack = [];

                for (const token of tokens) {
                    if (this.isVariable(token)) {
                        output.push(token);
                    } else if (token === '(') {
                        operatorStack.push(token);
                    } else if (token === ')') {
                        while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] !== '(') {
                            output.push(operatorStack.pop());
                        }
                        operatorStack.pop(); // Remove the '('
                    } else if (this.operators[token]) {
                        const currentOp = this.operators[token];
                        
                        while (operatorStack.length > 0) {
                            const topOp = operatorStack[operatorStack.length - 1];
                            if (topOp === '(' || !this.operators[topOp]) break;
                            
                            const topOpInfo = this.operators[topOp];
                            if ((currentOp.associativity === 'left' && currentOp.precedence <= topOpInfo.precedence) ||
                                (currentOp.associativity === 'right' && currentOp.precedence < topOpInfo.precedence)) {
                                output.push(operatorStack.pop());
                            } else {
                                break;
                            }
                        }
                        operatorStack.push(token);
                    }
                }

                while (operatorStack.length > 0) {
                    output.push(operatorStack.pop());
                }

                return output;
            }

            /**
             * Check if a token is a variable (not an operator or parenthesis)
             * @param {string} token - The token to check
             * @returns {boolean} True if token is a variable
             */
            isVariable(token) {
                return !this.operators[token] && token !== '(' && token !== ')';
            }

            /**
             * Extract all unique variables from an expression
             * @param {Array} tokens - Array of tokens
             * @returns {Array} Array of unique variable names
             */
            extractVariables(tokens) {
                const variables = new Set();
                for (const token of tokens) {
                    if (this.isVariable(token)) {
                        variables.add(token);
                    }
                }
                return Array.from(variables).sort();
            }

            /**
             * Evaluate a postfix expression with given variable assignments
             * @param {Array} postfix - Postfix notation tokens
             * @param {Object} assignments - Variable assignments {variable: boolean}
             * @returns {boolean} Result of the logical expression
             */
            evaluatePostfix(postfix, assignments) {
                const stack = [];

                for (const token of postfix) {
                    if (this.isVariable(token)) {
                        if (assignments[token] === undefined) {
                            throw new Error(`Variable '${token}' not assigned a value`);
                        }
                        stack.push(assignments[token]);
                    } else if (this.operators[token]) {
                        const op = this.operators[token];
                        
                        if (op.type === 'unary') {
                            if (stack.length < 1) throw new Error('Invalid expression: insufficient operands for unary operator');
                            const operand = stack.pop();
                            stack.push(this.applyUnaryOperator(token, operand));
                        } else if (op.type === 'binary') {
                            if (stack.length < 2) throw new Error('Invalid expression: insufficient operands for binary operator');
                            const right = stack.pop();
                            const left = stack.pop();
                            stack.push(this.applyBinaryOperator(token, left, right));
                        }
                    }
                }

                if (stack.length !== 1) {
                    throw new Error('Invalid expression: malformed');
                }

                return stack[0];
            }

            /**
             * Apply unary logical operators
             * @param {string} operator - The operator
             * @param {boolean} operand - The operand
             * @returns {boolean} Result of operation
             */
            applyUnaryOperator(operator, operand) {
                switch (operator) {
                    case 'NOT':
                    case '¬¨':
                        return !operand;
                    default:
                        throw new Error(`Unknown unary operator: ${operator}`);
                }
            }

            /**
             * Apply binary logical operators
             * @param {string} operator - The operator
             * @param {boolean} left - Left operand
             * @param {boolean} right - Right operand
             * @returns {boolean} Result of operation
             */
            applyBinaryOperator(operator, left, right) {
                switch (operator) {
                    case 'AND':
                    case '‚àß':
                        return left && right;
                    case 'OR':
                    case '‚à®':
                        return left || right;
                    case 'IMPLIES':
                    case '‚Üí':
                        return !left || right; // P ‚Üí Q is equivalent to ¬¨P ‚à® Q
                    case 'BICONDITIONAL':
                    case '‚Üî':
                        return left === right; // P ‚Üî Q is true when both have same truth value
                    default:
                        throw new Error(`Unknown binary operator: ${operator}`);
                }
            }

            /**
             * Generate all possible truth value combinations for given variables
             * @param {Array} variables - Array of variable names
             * @returns {Array} Array of assignment objects
             */
            generateTruthCombinations(variables) {
                const combinations = [];
                const numCombinations = Math.pow(2, variables.length);

                for (let i = 0; i < numCombinations; i++) {
                    const assignment = {};
                    for (let j = 0; j < variables.length; j++) {
                        assignment[variables[j]] = Boolean(i & (1 << (variables.length - 1 - j)));
                    }
                    combinations.push(assignment);
                }

                return combinations;
            }

            /**
             * Generate complete truth table for a logical expression
             * @param {string} expression - The logical expression
             * @returns {Object} Truth table with variables, combinations, and results
             */
            generateTruthTable(expression) {
                try {
                    const tokens = this.tokenize(expression);
                    const variables = this.extractVariables(tokens);
                    const postfix = this.infixToPostfix(tokens);
                    const combinations = this.generateTruthCombinations(variables);

                    const results = combinations.map(assignment => ({
                        assignment,
                        result: this.evaluatePostfix(postfix, assignment)
                    }));

                    return {
                        expression,
                        variables,
                        combinations: results,
                        isValid: true
                    };
                } catch (error) {
                    return {
                        expression,
                        error: error.message,
                        isValid: false
                    };
                }
            }

            /**
             * Evaluate an expression with specific variable assignments
             * @param {string} expression - The logical expression
             * @param {Object} assignments - Variable assignments
             * @returns {Object} Evaluation result
             */
            evaluate(expression, assignments) {
                try {
                    const tokens = this.tokenize(expression);
                    const postfix = this.infixToPostfix(tokens);
                    const result = this.evaluatePostfix(postfix, assignments);

                    return {
                        expression,
                        assignments,
                        result,
                        isValid: true
                    };
                } catch (error) {
                    return {
                        expression,
                        assignments,
                        error: error.message,
                        isValid: false
                    };
                }
            }

            /**
             * Check if player's choice satisfies the logical condition
             * @param {string} logicalRule - The logical rule to check against
             * @param {Object} playerChoice - Player's choice with variable assignments
             * @returns {Object} Validation result
             */
            validatePlayerChoice(logicalRule, playerChoice) {
                const evaluation = this.evaluate(logicalRule, playerChoice);
                
                return {
                    isCorrect: evaluation.isValid && evaluation.result === true,
                    evaluation,
                    explanation: this.generateExplanation(logicalRule, playerChoice, evaluation)
                };
            }

            /**
             * Generate human-readable explanation of the logical evaluation
             * @param {string} rule - The logical rule
             * @param {Object} choice - Player's choice
             * @param {Object} evaluation - Evaluation result
             * @returns {string} Human-readable explanation
             */
            generateExplanation(rule, choice, evaluation) {
                if (!evaluation.isValid) {
                    return `Error in logical rule: ${evaluation.error}`;
                }

                const assignments = Object.entries(choice)
                    .map(([variable, value]) => `${variable} = ${value}`)
                    .join(', ');

                const result = evaluation.result ? 'TRUE' : 'FALSE';
                
                return `Given ${assignments}, the logical rule "${rule}" evaluates to ${result}.`;
            }

            /**
             * Pretty print truth table to console (for debugging)
             * @param {Object} truthTable - Truth table object
             */
            printTruthTable(truthTable) {
                if (!truthTable.isValid) {
                    console.error('Invalid expression:', truthTable.error);
                    return;
                }

                console.log(`Truth Table for: ${truthTable.expression}`);
                console.log('='.repeat(50));
                
                // Header
                const header = truthTable.variables.join('\t') + '\tResult';
                console.log(header);
                console.log('-'.repeat(header.length));

                // Rows
                truthTable.combinations.forEach(combo => {
                    const values = truthTable.variables.map(v => combo.assignment[v] ? 'T' : 'F');
                    const result = combo.result ? 'T' : 'F';
                    console.log(values.join('\t') + '\t' + result);
                });
            }
        }

        // Create global logic engine instance
        const logicEngine = new LogicEngine();

        // ==================== ENHANCED GAME LOGIC ====================

        // DOM Elements
        const levelSelection = document.getElementById('level-selection');
        const foodLevelBtn = document.getElementById('food-level-btn');
        const medicalLevelBtn = document.getElementById('medical-level-btn');
        const militaryLevelBtn = document.getElementById('military-level-btn');
        const gameContainer = document.getElementById('game-container');
        const gameTitle = document.getElementById('game-title');
        const levelIndicator = document.getElementById('level-indicator');
        const scoreDisplay = document.getElementById('score-display');
        const scenarioEl = document.getElementById('scenario');
        const scenarioImageEl = document.getElementById('scenario-image');
        const scenarioTextEl = document.getElementById('scenario-text');
        const logicClueContainerEl = document.getElementById('logic-clue-container');
        const logicClueTextEl = document.getElementById('logic-clue-text');
        const logicClueSymbolicEl = document.getElementById('logic-clue-symbolic');
        const optionsContainerEl = document.getElementById('options-container');
        const feedbackContainerEl = document.getElementById('feedback-container');
        const feedbackTextEl = document.getElementById('feedback-text');
        const nextButton = document.getElementById('next-button');
        const restartButton = document.getElementById('restart-button');
        const bonusLevelButton = document.getElementById('bonus-level-button');

        // Gemini API Config
        const API_KEY = "";
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
        
        // Game State
        let currentStageIndex = 0;
        let score = 0;
        let bonusStage = null;
        let isPlayingBonus = false;
        let currentGameMode = 'food'; // 'food', 'medical', or 'military'

        const foodStages = [
            {
                image: 'üíß',
                scenario: 'A wide, muddy puddle blocks your path. What do you do?',
                logic: 'You will cross the gap without touching the ground if and only if you use a bridge-like object.',
                symbolic: 'Cross Gap ‚Üî Bridge',
                logicalRule: 'CrossGap BICONDITIONAL Bridge',
                variables: { CrossGap: 'Cross without touching ground', Bridge: 'Use bridge-like object' },
                options: [ 
                    { text: 'Jump in the puddle', correct: false, assignment: { CrossGap: false, Bridge: false } }, 
                    { text: 'Use a nearby plank', correct: true, assignment: { CrossGap: true, Bridge: true } }, 
                    { text: 'Wait for it to dry', correct: false, assignment: { CrossGap: false, Bridge: false } } 
                ],
                success: 'Clever! You walk across the plank, keeping your paws clean and dry.',
                failure: 'SPLASH! You\'re all muddy and no closer to the food. The puddle was too wide.'
            },
            {
                image: 'üêï',
                scenario: 'A large, barking dog is behind a tall, closed gate. You need to get past.',
                logic: 'If there is a dog AND the gate is closed, then you cannot pass and must find another way.',
                symbolic: '(Dog ‚àß Closed Gate) ‚Üí Find Another Way',
                logicalRule: '(Dog AND ClosedGate) IMPLIES FindAlternative',
                variables: { Dog: 'Dog present', ClosedGate: 'Gate is closed', FindAlternative: 'Find another way' },
                options: [ 
                    { text: 'Try to open the gate', correct: false, assignment: { Dog: true, ClosedGate: true, FindAlternative: false } }, 
                    { text: 'Bark back at the dog', correct: false, assignment: { Dog: true, ClosedGate: true, FindAlternative: false } }, 
                    { text: 'Look for an open window', correct: true, assignment: { Dog: true, ClosedGate: true, FindAlternative: true } } 
                ],
                success: 'Good thinking! The window leads you right past the angry dog.',
                failure: 'The gate is locked solid, and the dog just barks louder! Wasted time.'
            },
            {
                image: 'üö¶',
                scenario: 'The traffic is fast and the light for cars is green.',
                logic: 'It is safe for you to cross the road if and only if the cars have a red light.',
                symbolic: 'Safe Crossing ‚Üî Red Light',
                logicalRule: 'SafeCrossing BICONDITIONAL RedLight',
                variables: { SafeCrossing: 'Safe to cross', RedLight: 'Cars have red light' },
                options: [ 
                    { text: 'Dash across now', correct: false, assignment: { SafeCrossing: false, RedLight: false } }, 
                    { text: 'Wait for the red light', correct: true, assignment: { SafeCrossing: true, RedLight: true } }, 
                    { text: 'Try to sneak under a car', correct: false, assignment: { SafeCrossing: false, RedLight: false } } 
                ],
                success: 'Good patience! The light turns red, the cars stop, and you safely trot across.',
                failure: 'SCREECH! That was too close! You leap back to the curb, heart pounding.'
            },
            {
                image: 'üåßÔ∏è',
                scenario: 'Dark clouds burst open! It\'s pouring rain and you\'re getting soaked!',
                logic: 'If you do NOT want to get wet from the rain, then you must find cover.',
                symbolic: '¬¨(Get Wet) ‚Üí Find Cover',
                logicalRule: 'NOT GetWet IMPLIES FindCover',
                variables: { GetWet: 'Want to get wet', FindCover: 'Find cover' },
                options: [ 
                    { text: 'Keep running in the open', correct: false, assignment: { GetWet: false, FindCover: false } }, 
                    { text: 'Try to catch raindrops', correct: false, assignment: { GetWet: false, FindCover: false } }, 
                    { text: 'Hide under a parked car', correct: true, assignment: { GetWet: false, FindCover: true } } 
                ],
                success: 'Smart move! You huddle under the car, staying dry while the storm passes.',
                failure: 'You\'re soaked to the bone! You shiver and waste precious energy.'
            },
            {
                image: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶',
                scenario: 'A dense crowd of people is walking on the pavement, a forest of moving legs.',
                logic: 'If there is a crowd, you must find a path that is quiet AND NOT blocked, OR you must wait.',
                symbolic: 'Crowd ‚Üí ((Quiet Path ‚àß ¬¨Blocked) ‚à® Wait)',
                logicalRule: 'Crowd IMPLIES ((QuietPath AND NOT Blocked) OR Wait)',
                variables: { Crowd: 'Dense crowd present', QuietPath: 'Quiet path available', Blocked: 'Path is blocked', Wait: 'Choose to wait' },
                options: [ 
                    { text: 'Weave along the wall', correct: true, assignment: { Crowd: true, QuietPath: true, Blocked: false, Wait: false } }, 
                    { text: 'Dart through the middle', correct: false, assignment: { Crowd: true, QuietPath: false, Blocked: true, Wait: false } }, 
                    { text: 'Meow loudly at them', correct: false, assignment: { Crowd: true, QuietPath: false, Blocked: true, Wait: false } } 
                ],
                success: 'Excellent! The quiet, unblocked path along the wall lets you navigate the crowd.',
                failure: 'Oh no! You get caught in the forest of feet, getting kicked around and losing your way.'
            }
        ];

        const medicalStages = [
            {
                image: 'ü©∫',
                scenario: 'You\'re examining a patient with chest pain. The ECG shows irregular rhythms.',
                logic: 'If the patient has chest pain AND irregular ECG, then immediate cardiac assessment is required.',
                symbolic: '(Chest Pain ‚àß Irregular ECG) ‚Üí Cardiac Assessment',
                logicalRule: '(ChestPain AND IrregularECG) IMPLIES CardiacAssessment',
                variables: { ChestPain: 'Patient has chest pain', IrregularECG: 'ECG shows irregular rhythms', CardiacAssessment: 'Immediate cardiac assessment performed' },
                options: [ 
                    { text: 'Send patient home', correct: false, assignment: { ChestPain: true, IrregularECG: true, CardiacAssessment: false } }, 
                    { text: 'Order immediate cardiac enzymes', correct: true, assignment: { ChestPain: true, IrregularECG: true, CardiacAssessment: true } }, 
                    { text: 'Wait and observe only', correct: false, assignment: { ChestPain: true, IrregularECG: true, CardiacAssessment: false } } 
                ],
                success: 'Excellent diagnosis! Your quick thinking prevents a potential heart attack.',
                failure: 'The patient\'s condition worsens due to delayed treatment!'
            },
            {
                image: 'üíä',
                scenario: 'A patient is allergic to penicillin but has a severe bacterial infection.',
                logic: 'If patient is allergic to penicillin, then you must NOT use penicillin OR any beta-lactam antibiotics.',
                symbolic: 'Penicillin Allergy ‚Üí ¬¨(Penicillin ‚à® Beta-lactams)',
                logicalRule: 'PenicillinAllergy IMPLIES NOT (UsePenicillin OR UseBetaLactam)',
                variables: { PenicillinAllergy: 'Patient allergic to penicillin', UsePenicillin: 'Use penicillin', UseBetaLactam: 'Use beta-lactam antibiotics' },
                options: [ 
                    { text: 'Use amoxicillin anyway', correct: false, assignment: { PenicillinAllergy: true, UsePenicillin: false, UseBetaLactam: true } }, 
                    { text: 'Give no antibiotics', correct: false, assignment: { PenicillinAllergy: true, UsePenicillin: false, UseBetaLactam: false } }, 
                    { text: 'Use azithromycin instead', correct: true, assignment: { PenicillinAllergy: true, UsePenicillin: false, UseBetaLactam: false } } 
                ],
                success: 'Perfect! Azithromycin treats the infection without triggering the allergy.',
                failure: 'The patient goes into anaphylactic shock from the allergic reaction!'
            },
            {
                image: 'ü´Ä',
                scenario: 'During heart surgery, you need to decide on the bypass approach.',
                logic: 'A successful bypass requires both adequate vessel grafts AND proper blood flow restoration.',
                symbolic: 'Successful Bypass ‚Üî (Adequate Grafts ‚àß Blood Flow)',
                logicalRule: 'SuccessfulBypass BICONDITIONAL (AdequateGrafts AND BloodFlowRestoration)',
                variables: { SuccessfulBypass: 'Bypass surgery successful', AdequateGrafts: 'Use adequate vessel grafts', BloodFlowRestoration: 'Proper blood flow restoration' },
                options: [ 
                    { text: 'Use internal mammary artery graft', correct: true, assignment: { SuccessfulBypass: true, AdequateGrafts: true, BloodFlowRestoration: true } }, 
                    { text: 'Skip the graft procedure', correct: false, assignment: { SuccessfulBypass: false, AdequateGrafts: false, BloodFlowRestoration: false } }, 
                    { text: 'Use damaged vessel', correct: false, assignment: { SuccessfulBypass: false, AdequateGrafts: false, BloodFlowRestoration: false } } 
                ],
                success: 'Brilliant! The internal mammary artery provides excellent long-term results.',
                failure: 'Without proper grafts, the bypass fails and the patient\'s heart struggles!'
            },
            {
                image: 'üß†',
                scenario: 'A patient shows signs of stroke. Time is critical for treatment.',
                logic: 'If stroke symptoms appear within 4 hours, then thrombolytic therapy is indicated.',
                symbolic: '(Stroke ‚àß Within 4hrs) ‚Üí Thrombolytic Therapy',
                logicalRule: '(StrokeSymptoms AND Within4Hours) IMPLIES ThrombolyticTherapy',
                variables: { StrokeSymptoms: 'Patient shows stroke symptoms', Within4Hours: 'Symptoms within 4 hours', ThrombolyticTherapy: 'Administer thrombolytic therapy' },
                options: [ 
                    { text: 'Wait for more tests', correct: false, assignment: { StrokeSymptoms: true, Within4Hours: true, ThrombolyticTherapy: false } }, 
                    { text: 'Administer tPA immediately', correct: true, assignment: { StrokeSymptoms: true, Within4Hours: true, ThrombolyticTherapy: true } }, 
                    { text: 'Only give aspirin', correct: false, assignment: { StrokeSymptoms: true, Within4Hours: true, ThrombolyticTherapy: false } } 
                ],
                success: 'Quick action! The clot-busting medication restores blood flow to the brain.',
                failure: 'Delay causes permanent brain damage - time is brain tissue!'
            },
            {
                image: 'üî¨',
                scenario: 'Lab results show critically low blood sugar in an unconscious patient.',
                logic: 'If blood glucose is critically low AND patient is unconscious, then immediate glucose is required.',
                symbolic: '(Low Glucose ‚àß Unconscious) ‚Üí Immediate Glucose',
                logicalRule: '(LowGlucose AND Unconscious) IMPLIES ImmediateGlucose',
                variables: { LowGlucose: 'Blood glucose critically low', Unconscious: 'Patient unconscious', ImmediateGlucose: 'Give immediate glucose' },
                options: [ 
                    { text: 'Wait for the patient to wake up', correct: false, assignment: { LowGlucose: true, Unconscious: true, ImmediateGlucose: false } }, 
                    { text: 'Give insulin instead', correct: false, assignment: { LowGlucose: true, Unconscious: true, ImmediateGlucose: false } }, 
                    { text: 'Give IV dextrose immediately', correct: true, assignment: { LowGlucose: true, Unconscious: true, ImmediateGlucose: true } } 
                ],
                success: 'Life-saving! The glucose brings the patient back to consciousness.',
                failure: 'The patient slips deeper into hypoglycemic coma!'
            },
            {
                image: 'ü©π',
                scenario: 'A trauma patient has severe bleeding. You need to prioritize treatment.',
                logic: 'If there is severe bleeding, then you must control bleeding AND maintain blood pressure.',
                symbolic: 'Severe Bleeding ‚Üí (Control Bleeding ‚àß Maintain BP)',
                logicalRule: 'SevereBleeding IMPLIES (ControlBleeding AND MaintainBP)',
                variables: { SevereBleeding: 'Patient has severe bleeding', ControlBleeding: 'Control the bleeding', MaintainBP: 'Maintain blood pressure' },
                options: [ 
                    { text: 'Apply pressure and start IV fluids', correct: true, assignment: { SevereBleeding: true, ControlBleeding: true, MaintainBP: true } }, 
                    { text: 'Only apply pressure', correct: false, assignment: { SevereBleeding: true, ControlBleeding: true, MaintainBP: false } }, 
                    { text: 'Only give pain medication', correct: false, assignment: { SevereBleeding: true, ControlBleeding: false, MaintainBP: false } } 
                ],
                success: 'Perfect trauma management! You stop the bleeding and stabilize the patient.',
                failure: 'The patient goes into shock from blood loss!'
            },
            {
                image: 'ü´Å',
                scenario: 'A patient can\'t breathe properly. Oxygen saturation is dropping rapidly.',
                logic: 'If oxygen saturation is low AND breathing is compromised, then airway management is priority.',
                symbolic: '(Low O2 ‚àß Breathing Issues) ‚Üí Airway Management',
                logicalRule: '(LowOxygen AND BreathingCompromised) IMPLIES AirwayManagement',
                variables: { LowOxygen: 'Oxygen saturation low', BreathingCompromised: 'Breathing compromised', AirwayManagement: 'Perform airway management' },
                options: [ 
                    { text: 'Just give nasal oxygen', correct: false, assignment: { LowOxygen: true, BreathingCompromised: true, AirwayManagement: false } }, 
                    { text: 'Intubate and ventilate', correct: true, assignment: { LowOxygen: true, BreathingCompromised: true, AirwayManagement: true } }, 
                    { text: 'Wait and see', correct: false, assignment: { LowOxygen: true, BreathingCompromised: true, AirwayManagement: false } } 
                ],
                success: 'Excellent! You secure the airway and restore proper oxygenation.',
                failure: 'The patient suffers respiratory failure due to inadequate intervention!'
            },
            {
                image: 'ü¶¥',
                scenario: 'X-ray shows a complex fracture with potential nerve damage.',
                logic: 'If fracture is complex AND nerve damage is suspected, then immediate surgical consultation is needed.',
                symbolic: '(Complex Fracture ‚àß Nerve Damage) ‚Üí Surgical Consult',
                logicalRule: '(ComplexFracture AND NerveDamage) IMPLIES SurgicalConsult',
                variables: { ComplexFracture: 'Fracture is complex', NerveDamage: 'Nerve damage suspected', SurgicalConsult: 'Get surgical consultation' },
                options: [ 
                    { text: 'Apply simple splint only', correct: false, assignment: { ComplexFracture: true, NerveDamage: true, SurgicalConsult: false } }, 
                    { text: 'Give pain medication and discharge', correct: false, assignment: { ComplexFracture: true, NerveDamage: true, SurgicalConsult: false } }, 
                    { text: 'Call orthopedic surgeon immediately', correct: true, assignment: { ComplexFracture: true, NerveDamage: true, SurgicalConsult: true } } 
                ],
                success: 'Wise decision! Early surgical intervention prevents permanent disability.',
                failure: 'Delayed treatment leads to permanent nerve damage and disability!'
            },
            {
                image: 'ü©∏',
                scenario: 'Blood work reveals dangerously high potassium levels in a kidney patient.',
                logic: 'If potassium is dangerously high, then you must use treatments that lower potassium OR remove it.',
                symbolic: 'High K+ ‚Üí (Lower K+ ‚à® Remove K+)',
                logicalRule: 'HighPotassium IMPLIES (LowerPotassium OR RemovePotassium)',
                variables: { HighPotassium: 'Potassium dangerously high', LowerPotassium: 'Use treatment to lower potassium', RemovePotassium: 'Remove potassium from body' },
                options: [ 
                    { text: 'Give more potassium', correct: false, assignment: { HighPotassium: true, LowerPotassium: false, RemovePotassium: false } }, 
                    { text: 'Start dialysis immediately', correct: true, assignment: { HighPotassium: true, LowerPotassium: false, RemovePotassium: true } }, 
                    { text: 'Ignore the results', correct: false, assignment: { HighPotassium: true, LowerPotassium: false, RemovePotassium: false } } 
                ],
                success: 'Critical thinking! Dialysis removes the excess potassium and saves the heart.',
                failure: 'High potassium causes fatal heart rhythm abnormalities!'
            },
            {
                image: 'üë∂',
                scenario: 'A newborn baby is not breathing properly after delivery.',
                logic: 'If newborn is NOT breathing properly, then immediate resuscitation AND airway clearance are required.',
                symbolic: '¬¨(Proper Breathing) ‚Üí (Resuscitation ‚àß Airway Clearing)',
                logicalRule: 'NOT ProperBreathing IMPLIES (Resuscitation AND AirwayClearing)',
                variables: { ProperBreathing: 'Newborn breathing properly', Resuscitation: 'Perform resuscitation', AirwayClearing: 'Clear airway' },
                options: [ 
                    { text: 'Just wait and observe', correct: false, assignment: { ProperBreathing: false, Resuscitation: false, AirwayClearing: false } }, 
                    { text: 'Only stimulate the baby', correct: false, assignment: { ProperBreathing: false, Resuscitation: true, AirwayClearing: false } }, 
                    { text: 'Suction airway and provide ventilation', correct: true, assignment: { ProperBreathing: false, Resuscitation: true, AirwayClearing: true } } 
                ],
                success: 'Perfect neonatal care! The baby starts breathing and crying healthily.',
                failure: 'The newborn suffers from lack of oxygen - brain damage may occur!'
            }
        ];

        const militaryStages = [
            {
                image: 'üéØ',
                scenario: 'Enemy scouts spotted 2km ahead. Your reconnaissance team needs to gather intel.',
                logic: 'If enemy is detected AND stealth is maintained, then successful reconnaissance is possible.',
                symbolic: '(Enemy Detected ‚àß Stealth) ‚Üí Successful Recon',
                options: [ { text: 'Charge directly at the enemy', correct: false }, { text: 'Use binoculars from concealed position', correct: true }, { text: 'Retreat without gathering intel', correct: false } ],
                success: 'Outstanding! You gather critical intelligence while remaining undetected.',
                failure: 'Your position is compromised! The enemy is now aware of your presence.'
            },
            {
                image: 'üí•',
                scenario: 'Artillery strike incoming! You have 30 seconds to take cover.',
                logic: 'If artillery is incoming, then you must seek hard cover OR evacuate the danger zone.',
                symbolic: 'Artillery ‚Üí (Hard Cover ‚à® Evacuate)',
                options: [ { text: 'Stand and fight the artillery', correct: false }, { text: 'Hide behind a tree', correct: false }, { text: 'Dive into the reinforced bunker', correct: true } ],
                success: 'Smart tactical decision! The bunker protects you from the explosion.',
                failure: 'BOOM! The inadequate cover fails to protect your squad from shrapnel!'
            },
            {
                image: 'üì°',
                scenario: 'Radio communication is jammed. You need to coordinate with HQ urgently.',
                logic: 'If communication is jammed AND message is urgent, then alternative communication method is required.',
                symbolic: '(Jammed ‚àß Urgent) ‚Üí Alternative Comms',
                options: [ { text: 'Use signal flares as planned', correct: true }, { text: 'Keep trying the jammed radio', correct: false }, { text: 'Give up communication', correct: false } ],
                success: 'Excellent! The pre-arranged signal flares successfully reach headquarters.',
                failure: 'Without communication, your mission coordination fails catastrophically!'
            },
            {
                image: 'üõ°Ô∏è',
                scenario: 'Your squad is under heavy fire. You need to establish defensive positions.',
                logic: 'If under enemy fire, then you must seek cover AND return suppressive fire.',
                symbolic: 'Enemy Fire ‚Üí (Seek Cover ‚àß Suppressive Fire)',
                options: [ { text: 'Charge the enemy position', correct: false }, { text: 'Take cover and return coordinated fire', correct: true }, { text: 'Only take cover without firing back', correct: false } ],
                success: 'Perfect tactics! Your suppressive fire allows the squad to maneuver safely.',
                failure: 'Without proper response, the enemy pins down your entire squad!'
            },
            {
                image: 'üöÅ',
                scenario: 'Helicopter extraction in 5 minutes. Enemy forces approaching the LZ.',
                logic: 'If extraction is imminent AND enemies approach, then you must secure the LZ OR delay enemies.',
                symbolic: '(Extraction ‚àß Enemy Approach) ‚Üí (Secure LZ ‚à® Delay Enemy)',
                options: [ { text: 'Abandon the landing zone', correct: false }, { text: 'Try to hide from enemies', correct: false }, { text: 'Set up defensive perimeter around LZ', correct: true } ],
                success: 'Tactical brilliance! Your perimeter holds until the helicopter arrives safely.',
                failure: 'The unsecured LZ becomes a killing zone - extraction impossible!'
            },
            {
                image: 'üí£',
                scenario: 'IED detected on your patrol route. Your squad\'s safety depends on your decision.',
                logic: 'If IED is detected, then you must NOT proceed on current route AND call explosive disposal.',
                symbolic: 'IED ‚Üí (¬¨Current Route ‚àß EOD Call)',
                options: [ { text: 'Try to disarm it yourself', correct: false }, { text: 'Mark area and call bomb disposal', correct: true }, { text: 'Continue on the same route', correct: false } ],
                success: 'Life-saving decision! EOD safely disarms the device - zero casualties.',
                failure: 'EXPLOSION! Your poor decision results in multiple squad casualties!'
            },
            {
                image: 'üåô',
                scenario: 'Night mission: infiltrate enemy compound. Guards have night vision.',
                logic: 'If enemies have night vision AND you need stealth, then infrared concealment is required.',
                symbolic: '(Night Vision ‚àß Stealth Needed) ‚Üí IR Concealment',
                options: [ { text: 'Rely on darkness alone', correct: false }, { text: 'Use bright flashlights', correct: false }, { text: 'Use thermal camouflage blankets', correct: true } ],
                success: 'Stealth master! Your thermal concealment makes you invisible to their equipment.',
                failure: 'Detected! The enemy night vision spots your heat signature immediately.'
            },
            {
                image: '‚õΩ',
                scenario: 'Fuel convoy ambushed. Protect the supply line or risk mission failure.',
                logic: 'If convoy is critical AND under attack, then immediate support AND route security are needed.',
                symbolic: '(Critical Convoy ‚àß Attack) ‚Üí (Support ‚àß Route Security)',
                options: [ { text: 'Deploy rapid response and secure flanks', correct: true }, { text: 'Let convoy handle it alone', correct: false }, { text: 'Only send minimal support', correct: false } ],
                success: 'Outstanding leadership! The convoy reaches base with supplies intact.',
                failure: 'Supply line severed! Your forces run out of fuel and ammunition.'
            },
            {
                image: 'üó∫Ô∏è',
                scenario: 'Intelligence reports enemy reinforcements. You must choose your battle strategy.',
                logic: 'If enemy has reinforcements, then you must use superior tactics OR avoid direct confrontation.',
                symbolic: 'Enemy Reinforcements ‚Üí (Superior Tactics ‚à® Avoid Confrontation)',
                options: [ { text: 'Attack head-on despite odds', correct: false }, { text: 'Execute flanking maneuver', correct: true }, { text: 'Wait for enemy to attack first', correct: false } ],
                success: 'Tactical genius! Your flanking maneuver catches the enemy completely off-guard.',
                failure: 'Frontal assault against superior numbers results in devastating losses!'
            },
            {
                image: 'üèÜ',
                scenario: 'Final assault on enemy stronghold. Victory depends on perfect coordination.',
                logic: 'If final assault AND perfect coordination needed, then all units must execute simultaneously.',
                symbolic: '(Final Assault ‚àß Coordination) ‚Üí Simultaneous Execution',
                options: [ { text: 'Attack with only one unit', correct: false }, { text: 'Wait for enemy surrender', correct: false }, { text: 'Coordinate synchronized multi-front attack', correct: true } ],
                success: 'VICTORY! Your masterful coordination overwhelms the enemy stronghold!',
                failure: 'Uncoordinated attack fails! The stronghold remains in enemy hands.'
            }
        ];

        const finalStages = {
            food: {
                image: 'üêü',
                scenario: 'YOU MADE IT! You avoided all the dangers. The delicious bowl of fish is finally yours!',
                logic: 'Congratulations!',
                symbolic: 'üèÜ',
                options: [],
                success: (finalScore) => `You finished with a score of ${finalScore}! Enjoy your well-deserved meal!`,
                failure: ''
            },
            medical: {
                image: 'üè•',
                scenario: 'CONGRATULATIONS DR. CAT! You successfully completed all 10 medical procedures and saved many lives!',
                logic: 'Outstanding Medical Excellence!',
                symbolic: '‚öïÔ∏èüèÜ',
                options: [],
                success: (finalScore) => `Dr. Cat achieved a final score of ${finalScore}! You are a true medical hero!`,
                failure: ''
            },
            military: {
                image: 'üéñÔ∏è',
                scenario: 'MISSION ACCOMPLISHED, COLONEL CAT! You have successfully completed all military operations and led your forces to victory!',
                logic: 'Outstanding Military Leadership!',
                symbolic: '‚öîÔ∏èüèÜ',
                options: [],
                success: (finalScore) => `Colonel Cat earned a final score of ${finalScore}! You are a legendary military strategist!`,
                failure: ''
            }
        };

        function generateRandomBonusStage() {
            // Combine all scenarios from all three levels
            const allStages = [...foodStages, ...medicalStages, ...militaryStages];
            
            // Randomly select a stage from any level
            const randomIndex = Math.floor(Math.random() * allStages.length);
            const selectedStage = allStages[randomIndex];
            
            // Determine which level this stage is from for theming
            let stageType = 'combo';
            let themeEmoji = 'üéØ';
            let themeTitle = 'Mixed Challenge';
            
            if (randomIndex < foodStages.length) {
                stageType = 'food';
                themeEmoji = 'üê±';
                themeTitle = 'Food Quest Bonus';
            } else if (randomIndex < foodStages.length + medicalStages.length) {
                stageType = 'medical';
                themeEmoji = '‚öïÔ∏è';
                themeTitle = 'Medical Emergency Bonus';
            } else {
                stageType = 'military';
                themeEmoji = '‚öîÔ∏è';
                themeTitle = 'Military Operation Bonus';
            }
            
            // Create a bonus version of the selected stage with shuffled options
            const shuffledOptions = [...selectedStage.options];
            // Fisher-Yates shuffle algorithm to randomize option order
            for (let i = shuffledOptions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledOptions[i], shuffledOptions[j]] = [shuffledOptions[j], shuffledOptions[i]];
            }
            
            return {
                ...selectedStage,
                options: shuffledOptions,
                scenario: `üé≤ BONUS CHALLENGE - ${themeTitle}: ${selectedStage.scenario}`,
                success: `${themeEmoji} BONUS SUCCESS! ${selectedStage.success} (+15 bonus points!)`,
                failure: `${themeEmoji} BONUS FAILED! ${selectedStage.failure} (No bonus points)`
            };
        }

        function resetGame() {
            currentStageIndex = 0;
            score = 0;
            isPlayingBonus = false;
            bonusStage = null;
            scoreDisplay.textContent = `Score: ${score}`;
            levelSelection.classList.remove('hidden');
            gameContainer.classList.add('hidden');
            levelSelection.classList.add('fade-in');
        }
        
        function startGame(gameMode) {
            currentGameMode = gameMode;
            score = 0;
            currentStageIndex = 0;
            isPlayingBonus = false;
            scoreDisplay.textContent = `Score: ${score}`;
            
            // Update UI based on game mode
            if (gameMode === 'medical') {
                gameTitle.textContent = "Dr. Cat's Hospital";
                levelIndicator.textContent = "Medical Level";
                levelIndicator.className = "bg-red-600 text-white font-bold px-3 py-1 rounded-lg text-sm";
            } else if (gameMode === 'military') {
                gameTitle.textContent = "Colonel Cat's War";
                levelIndicator.textContent = "Military Operations";
                levelIndicator.className = "bg-green-600 text-white font-bold px-3 py-1 rounded-lg text-sm";
            } else {
                gameTitle.textContent = "The Cat's Quest";
                levelIndicator.textContent = "Food Quest";
                levelIndicator.className = "bg-blue-600 text-white font-bold px-3 py-1 rounded-lg text-sm";
            }
            
            levelSelection.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            gameContainer.classList.add('fade-in');
            renderStage();
        }

        function renderStage() {
            feedbackContainerEl.classList.add('hidden');
            optionsContainerEl.style.pointerEvents = 'auto';
            optionsContainerEl.style.opacity = '1';

            const currentStages = currentGameMode === 'medical' ? medicalStages : 
                                 currentGameMode === 'military' ? militaryStages : foodStages;
            let stage;
            
            if (isPlayingBonus) {
                stage = bonusStage;
            } else if (currentStageIndex < currentStages.length) {
                stage = currentStages[currentStageIndex];
            } else {
                stage = finalStages[currentGameMode];
            }

            if (!stage) { resetGame(); return; }

            // Apply animations
            scenarioEl.classList.remove('fade-in');
            void scenarioEl.offsetWidth; // Trigger reflow
            scenarioEl.classList.add('fade-in');

            scenarioImageEl.textContent = stage.image;
            scenarioTextEl.textContent = stage.scenario;
            logicClueTextEl.textContent = stage.logic;
            logicClueSymbolicEl.textContent = stage.symbolic;
            
            if (stage.options && stage.options.length > 0) {
                logicClueContainerEl.classList.remove('hidden', 'fade-in');
                void logicClueContainerEl.offsetWidth;
                logicClueContainerEl.classList.add('fade-in');
            } else {
                logicClueContainerEl.classList.add('hidden');
            }

            optionsContainerEl.innerHTML = '';
            
            if (!stage.options || stage.options.length === 0) {
                // Final/Thank You Page
                isPlayingBonus = false;
                feedbackTextEl.textContent = stage.success(score);
                feedbackTextEl.classList.remove('text-red-500');
                feedbackTextEl.classList.add('text-green-500');
                feedbackContainerEl.classList.remove('hidden');
                nextButton.classList.add('hidden');
                restartButton.classList.remove('hidden');
                bonusLevelButton.classList.remove('hidden');
                restartButton.textContent = 'Play Again?';
            } else {
                 stage.options.forEach((option, index) => {
                    const button = document.createElement('button');
                    button.textContent = option.text;
                    button.className = 'w-full px-4 py-4 bg-gray-700 hover:bg-amber-500 rounded-lg shadow-md transform hover:scale-105 transition-all duration-200 slide-in-up';
                    button.style.animationDelay = `${index * 100}ms`;
                    button.onclick = () => handleOptionClick(option);
                    optionsContainerEl.appendChild(button);
                 });
            }
        }

        function handleOptionClick(option) {
            optionsContainerEl.style.pointerEvents = 'none';
            feedbackContainerEl.classList.remove('hidden');
            logicClueContainerEl.classList.add('hidden');

            const currentStages = currentGameMode === 'medical' ? medicalStages : 
                                 currentGameMode === 'military' ? militaryStages : foodStages;
            const stage = isPlayingBonus ? bonusStage : currentStages[currentStageIndex];

            // Use logic engine for validation if stage has logical rules
            let isCorrect;
            let explanation = '';
            
            if (stage.logicalRule && option.assignment) {
                // Use logic engine to validate the choice
                const validation = logicEngine.validatePlayerChoice(stage.logicalRule, option.assignment);
                isCorrect = validation.isCorrect;
                explanation = validation.explanation;
                
                // Debug: Print truth table for this logical rule (console)
                if (window.location.search.includes('debug=true')) {
                    console.log(`\n=== STAGE ${currentStageIndex + 1} LOGIC ANALYSIS ===`);
                    const truthTable = logicEngine.generateTruthTable(stage.logicalRule);
                    logicEngine.printTruthTable(truthTable);
                    console.log('\nPlayer Choice Analysis:');
                    console.log('Variables:', stage.variables);
                    console.log('Assignment:', option.assignment);
                    console.log('Validation:', validation);
                    console.log('=====================\n');
                }
            } else {
                // Fallback to original validation method
                isCorrect = option.correct;
            }

            if (isCorrect) {
                // Give extra points for bonus levels
                const pointsEarned = isPlayingBonus ? 15 : 10;
                score += pointsEarned;
                scoreDisplay.textContent = `Score: ${score}`;
                feedbackTextEl.textContent = stage.success;
                feedbackTextEl.classList.remove('text-red-500');
                feedbackTextEl.classList.add('text-green-500');
                
                // Add logic explanation if available
                if (explanation) {
                    feedbackTextEl.innerHTML = stage.success + '<br><small class="text-green-300">Logic: ' + explanation + '</small>';
                }
                
                if (isPlayingBonus) {
                    nextButton.classList.add('hidden');
                    restartButton.classList.remove('hidden');
                    bonusLevelButton.classList.remove('hidden');
                    restartButton.textContent = 'Play From Start';
                    bonusLevelButton.textContent = '‚ú® Generate Another Bonus';
                } else {
                     nextButton.classList.remove('hidden');
                     restartButton.classList.add('hidden');
                     bonusLevelButton.classList.add('hidden');
                }
            } else {
                // Deduct points for wrong answer, but don't let score go below 0
                const pointsLost = isPlayingBonus ? 10 : 5;
                score = Math.max(0, score - pointsLost);
                scoreDisplay.textContent = `Score: ${score}`;
                feedbackTextEl.textContent = stage.failure + ` (-${pointsLost} points)`;
                feedbackTextEl.classList.remove('text-green-500');
                feedbackTextEl.classList.add('text-red-500');
                
                // Add logic explanation if available
                if (explanation) {
                    feedbackTextEl.innerHTML = stage.failure + ` (-${pointsLost} points)<br><small class="text-red-300">Logic: ` + explanation + '</small>';
                }
                
                nextButton.classList.add('hidden');
                restartButton.classList.remove('hidden');
                bonusLevelButton.classList.add('hidden');
                restartButton.textContent = 'Try Again?';
            }
        }
        
        function generateBonusLevel() {
            try {
                const generatedStage = generateRandomBonusStage();
                if (generatedStage) {
                    bonusStage = generatedStage;
                    isPlayingBonus = true;
                    renderStage();
                } else {
                    // Handle generation failure
                    scenarioTextEl.textContent = 'Sorry, I couldn\'t generate a bonus challenge right now. Please try again!';
                    feedbackContainerEl.classList.remove('hidden');
                    restartButton.classList.remove('hidden');
                    bonusLevelButton.classList.add('hidden');
                }
            } catch (error) {
                console.error('Error generating bonus level:', error);
                scenarioTextEl.textContent = 'Sorry, I couldn\'t generate a bonus challenge right now. Please try again!';
                feedbackContainerEl.classList.remove('hidden');
                restartButton.classList.remove('hidden');
                bonusLevelButton.classList.add('hidden');
            }
        }

        // Event Listeners
        foodLevelBtn.addEventListener('click', () => startGame('food'));
        medicalLevelBtn.addEventListener('click', () => startGame('medical'));
        militaryLevelBtn.addEventListener('click', () => startGame('military'));
        nextButton.addEventListener('click', () => { currentStageIndex++; renderStage(); });
        restartButton.addEventListener('click', () => {
            const maxStages = currentGameMode === 'medical' ? medicalStages.length : 
                             currentGameMode === 'military' ? militaryStages.length : foodStages.length;
            if (isPlayingBonus || currentStageIndex >= maxStages) {
                resetGame();
            } else {
                // If it's "Try Again" on a normal level, just re-render the same stage
                renderStage();
            }
        });
        bonusLevelButton.addEventListener('click', generateBonusLevel);

        // ==================== LOGIC ENGINE DEMO & TESTING ====================
        
        /**
         * Demo function to showcase the logic engine capabilities
         * Call this in browser console: demoLogicEngine()
         */
        window.demoLogicEngine = function() {
            console.log('üß† LOGIC ENGINE DEMONSTRATION üß†');
            console.log('='.repeat(50));
            
            // Test various logical expressions
            const testExpressions = [
                'P AND Q',
                'P OR Q', 
                'P IMPLIES Q',
                'P BICONDITIONAL Q',
                'NOT P',
                '(P AND Q) OR R',
                '(P OR Q) AND (R OR S)',
                'P IMPLIES (Q AND R)',
                'NOT (P AND Q) BICONDITIONAL (NOT P OR NOT Q)'
            ];
            
            testExpressions.forEach(expr => {
                console.log(`\n--- Expression: ${expr} ---`);
                const truthTable = logicEngine.generateTruthTable(expr);
                logicEngine.printTruthTable(truthTable);
            });
            
            // Test specific evaluation
            console.log('\n--- SPECIFIC EVALUATION TEST ---');
            const evaluation = logicEngine.evaluate('(P AND Q) IMPLIES R', {P: true, Q: false, R: true});
            console.log('Expression: (P AND Q) IMPLIES R');
            console.log('Assignment: P=true, Q=false, R=true');
            console.log('Result:', evaluation);
            
            console.log('\n--- GAME STAGE LOGIC TEST ---');
            if (foodStages[0].logicalRule) {
                const stage = foodStages[0];
                console.log('Stage 1 Logic Rule:', stage.logicalRule);
                console.log('Variables:', stage.variables);
                
                stage.options.forEach((option, index) => {
                    if (option.assignment) {
                        const validation = logicEngine.validatePlayerChoice(stage.logicalRule, option.assignment);
                        console.log(`Option ${index + 1} (${option.text}):`, validation);
                    }
                });
            }
        };

        /**
         * Interactive logic evaluator - call in console
         * Example: evaluateLogic('P AND Q', {P: true, Q: false})
         */
        window.evaluateLogic = function(expression, assignments) {
            console.log(`\nüîç Evaluating: ${expression}`);
            console.log('Assignments:', assignments);
            
            const evaluation = logicEngine.evaluate(expression, assignments);
            console.log('Result:', evaluation);
            
            const truthTable = logicEngine.generateTruthTable(expression);
            logicEngine.printTruthTable(truthTable);
            
            return evaluation;
        };

        /**
         * Generate truth table for any expression - call in console
         * Example: truthTable('P IMPLIES (Q AND R)')
         */
        window.truthTable = function(expression) {
            console.log(`\nüìä Truth Table for: ${expression}`);
            const table = logicEngine.generateTruthTable(expression);
            logicEngine.printTruthTable(table);
            return table;
        };

        // Initialize logic engine testing in console
        console.log('üéÆ LOGIC GAME ENGINE LOADED! üéÆ');
        console.log('Available debug functions:');
        console.log('‚Ä¢ demoLogicEngine() - Full demonstration');
        console.log('‚Ä¢ evaluateLogic(expression, assignments) - Test specific cases');
        console.log('‚Ä¢ truthTable(expression) - Generate truth table');
        console.log('‚Ä¢ Add ?debug=true to URL for detailed game logic analysis');
        console.log('='.repeat(60));
    </script>
</body>
</html>
