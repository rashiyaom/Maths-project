<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Cat's Quest: A Logic Adventure</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Gaegu:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Gaegu', cursive;
        }
        .vignette {
            box-shadow: inset 0 0 100px rgba(0,0,0,0.4);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes slideInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
        .slide-in-up {
            animation: slideInUp 0.5s ease-out forwards;
        }
        .symbol-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            padding: 1rem;
            transition: transform 0.2s ease, background 0.2s ease;
        }
        .symbol-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body class="bg-gray-800 text-white flex items-center justify-center min-h-screen p-4">

    <!-- Start Screen -->
    <div id="start-screen" class="w-full max-w-3xl bg-gray-900 rounded-2xl shadow-2xl p-6 md:p-8 border-4 border-gray-700 text-center fade-in">
        <h1 class="text-4xl md:text-5xl font-bold text-amber-400 mb-4">Welcome to The Cat's Quest!</h1>
        <p class="text-lg text-gray-300 mb-6">A game of logic, wit, and whiskered adventure.</p>
        
        <div class="text-left bg-gray-800 p-6 rounded-lg border border-gray-700">
            <h2 class="text-2xl font-bold text-amber-300 mb-4">How to Play</h2>
            <p class="mb-2">Your goal is to help a hungry cat navigate a series of urban challenges to reach its food. In each stage, you will be presented with a scenario and a <strong class="text-white">Logical Rule</strong>.</p>
            <p class="mb-4">Choose the one option that correctly follows the rule to advance and earn <strong class="text-white">10 points</strong>. A wrong choice will end your quest!</p>

            <h3 class="text-xl font-bold text-amber-300 mt-6 mb-4">Understanding the Logic</h3>
            <p class="mb-4">These symbols represent different types of logical statements:</p>
            <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                <div class="symbol-card">
                    <p class="text-3xl font-mono text-cyan-400">P ‚Üí Q</p>
                    <p class="mt-2"><strong>THEN (Conditional)</strong></p>
                    <p class="text-sm text-gray-400">If P is true, then Q must be true.</p>
                </div>
                <div class="symbol-card">
                    <p class="text-3xl font-mono text-cyan-400">P ‚Üî Q</p>
                    <p class="mt-2"><strong>IF AND ONLY IF</strong></p>
                    <p class="text-sm text-gray-400">P is true only when Q is true, and vice-versa.</p>
                </div>
                <div class="symbol-card">
                    <p class="text-3xl font-mono text-cyan-400">¬¨P</p>
                    <p class="mt-2"><strong>NOT (Negation)</strong></p>
                    <p class="text-sm text-gray-400">The opposite of P.</p>
                </div>
                <div class="symbol-card">
                    <p class="text-3xl font-mono text-cyan-400">P ‚àß Q</p>
                    <p class="mt-2"><strong>AND (Conjunction)</strong></p>
                    <p class="text-sm text-gray-400">Both P and Q must be true.</p>
                </div>
                <div class="symbol-card">
                    <p class="text-3xl font-mono text-cyan-400">P ‚à® Q</p>
                    <p class="mt-2"><strong>OR (Disjunction)</strong></p>
                    <p class="text-sm text-gray-400">Either P is true, or Q is true, or both.</p>
                </div>
            </div>
        </div>
        
        <button id="start-button" class="mt-8 px-10 py-4 bg-green-600 hover:bg-green-700 rounded-lg shadow-lg transform hover:scale-105 transition-transform text-2xl font-bold">Start the Quest!</button>
    </div>

    <!-- Game Container -->
    <div id="game-container" class="w-full max-w-2xl bg-gray-900 rounded-2xl shadow-2xl p-6 md:p-8 border-4 border-gray-700 text-center hidden">
        <div class="relative mb-4">
            <h1 class="text-4xl md:text-5xl font-bold text-amber-400">The Cat's Quest</h1>
            <div id="score-display" class="absolute top-0 right-0 bg-amber-400 text-gray-900 font-bold px-4 py-2 rounded-lg text-xl">Score: 0</div>
        </div>

        <!-- Conditional Statement Clue -->
        <div id="logic-clue-container" class="bg-amber-100 border-2 border-dashed border-amber-400 text-amber-900 rounded-lg p-4 mb-6 hidden">
            <p class="font-bold text-lg">Logical Rule:</p>
            <p id="logic-clue-text" class="text-lg"></p>
            <p id="logic-clue-symbolic" class="text-2xl font-mono mt-2"></p>
        </div>
        
        <!-- Dynamic Content Area -->
        <div id="scenario" class="bg-gray-800 rounded-lg p-6 mb-6 vignette border border-gray-700 min-h-[250px] flex flex-col items-center justify-center">
            <div id="scenario-image" class="text-6xl mb-4"></div>
            <p id="scenario-text" class="text-xl md:text-2xl text-gray-200"></p>
        </div>

        <!-- Options -->
        <div id="options-container" class="grid grid-cols-1 md:grid-cols-3 gap-4"></div>

        <!-- Feedback Message -->
        <div id="feedback-container" class="mt-6 text-2xl font-bold hidden">
            <p id="feedback-text"></p>
            <div class="flex justify-center items-center gap-4 mt-4 flex-wrap">
                <button id="next-button" class="px-8 py-3 bg-green-600 hover:bg-green-700 rounded-lg shadow-lg transform hover:scale-105 transition-transform">Next</button>
                <button id="restart-button" class="px-8 py-3 bg-red-600 hover:bg-red-700 rounded-lg shadow-lg transform hover:scale-105 transition-transform hidden">Try Again</button>
                <button id="bonus-level-button" class="px-8 py-3 bg-purple-600 hover:bg-purple-700 rounded-lg shadow-lg transform hover:scale-105 transition-transform hidden">‚ú® Generate Bonus Level</button>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score-display');
        const scenarioEl = document.getElementById('scenario');
        const scenarioImageEl = document.getElementById('scenario-image');
        const scenarioTextEl = document.getElementById('scenario-text');
        const logicClueContainerEl = document.getElementById('logic-clue-container');
        const logicClueTextEl = document.getElementById('logic-clue-text');
        const logicClueSymbolicEl = document.getElementById('logic-clue-symbolic');
        const optionsContainerEl = document.getElementById('options-container');
        const feedbackContainerEl = document.getElementById('feedback-container');
        const feedbackTextEl = document.getElementById('feedback-text');
        const nextButton = document.getElementById('next-button');
        const restartButton = document.getElementById('restart-button');
        const bonusLevelButton = document.getElementById('bonus-level-button');

        // Gemini API Config
        const API_KEY = "";
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
        
        // Game State
        let currentStageIndex = 0;
        let score = 0;
        let bonusStage = null;
        let isPlayingBonus = false;

        const stages = [
            {
                image: 'üíß',
                scenario: 'A wide, muddy puddle blocks your path. What do you do?',
                logic: 'You will cross the gap without touching the ground if and only if you use a bridge-like object.',
                symbolic: 'Cross Gap ‚Üî Bridge',
                options: [ { text: 'Use a nearby plank', correct: true }, { text: 'Jump in the puddle', correct: false }, { text: 'Wait for it to dry', correct: false } ],
                success: 'Clever! You walk across the plank, keeping your paws clean and dry.',
                failure: 'SPLASH! You\'re all muddy and no closer to the food. The puddle was too wide.'
            },
            {
                image: 'üêï',
                scenario: 'A large, barking dog is behind a tall, closed gate. You need to get past.',
                logic: 'If there is a dog AND the gate is closed, then you cannot pass and must find another way.',
                symbolic: '(Dog ‚àß Closed Gate) ‚Üí Find Another Way',
                options: [ { text: 'Look for an open window', correct: true }, { text: 'Try to open the gate', correct: false }, { text: 'Bark back at the dog', correct: false } ],
                success: 'Good thinking! The window leads you right past the angry dog.',
                failure: 'The gate is locked solid, and the dog just barks louder! Wasted time.'
            },
            {
                image: 'üö¶',
                scenario: 'The traffic is fast and the light for cars is green.',
                logic: 'It is safe for you to cross the road if and only if the cars have a red light.',
                symbolic: 'Safe Crossing ‚Üî Red Light',
                options: [ { text: 'Dash across now', correct: false }, { text: 'Wait for the red light', correct: true }, { text: 'Try to sneak under a car', correct: false } ],
                success: 'Good patience! The light turns red, the cars stop, and you safely trot across.',
                failure: 'SCREECH! That was too close! You leap back to the curb, heart pounding.'
            },
            {
                image: 'üåßÔ∏è',
                scenario: 'Dark clouds burst open! It\'s pouring rain and you\'re getting soaked!',
                logic: 'If you do NOT want to get wet from the rain, then you must find cover.',
                symbolic: '¬¨(Get Wet) ‚Üí Find Cover',
                options: [ { text: 'Hide under a parked car', correct: true }, { text: 'Keep running in the open', correct: false }, { text: 'Try to catch raindrops', correct: false } ],
                success: 'Smart move! You huddle under the car, staying dry while the storm passes.',
                failure: 'You\'re soaked to the bone! You shiver and waste precious energy.'
            },
            {
                image: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶',
                scenario: 'A dense crowd of people is walking on the pavement, a forest of moving legs.',
                logic: 'If there is a crowd, you must find a path that is quiet AND NOT blocked, OR you must wait.',
                symbolic: 'Crowd ‚Üí ((Quiet Path ‚àß ¬¨Blocked) ‚à® Wait)',
                options: [ { text: 'Dart through the middle', correct: false }, { text: 'Weave along the wall', correct: true }, { text: 'Meow loudly at them', correct: false } ],
                success: 'Excellent! The quiet, unblocked path along the wall lets you navigate the crowd.',
                failure: 'Oh no! You get caught in the forest of feet, getting kicked around and losing your way.'
            }
        ];

        const finalStage = {
            image: 'üêü',
            scenario: 'YOU MADE IT! You avoided all the dangers. The delicious bowl of fish is finally yours!',
            logic: 'Congratulations!',
            symbolic: 'üèÜ',
            options: [],
            success: (finalScore) => `You finished with a score of ${finalScore}! Enjoy your well-deserved meal!`,
            failure: ''
        };

        async function callGeminiForNewStage() {
            // ... (rest of the function remains the same, but prompt is updated)
            const prompt = `You are a creative game designer for a children's logic game. Your task is to generate a new, single challenge for a cat. The cat has already faced several urban challenges. Create a *new* one.

The response must be a single, valid JSON object. For the logic, you MUST use a variety of logical operators for the puzzles, including complex, nested statements. Use these operators:
- Simple Conditional ('If P, then Q')
- Biconditional ('P if and only if Q')
- Negation ('If NOT P, then Q')
- Conjunction ('If P AND R, then Q')
- Disjunction ('If P OR R, then Q')

The JSON object must have these keys:
- "image": A single, relevant emoji (string).
- "scenario": A short scenario for the cat (string).
- "logic": A conditional statement using one or more of the above logical forms (string).
- "symbolic": A short, symbolic representation. Use these symbols: '‚Üí', '‚Üî', '¬¨', '‚àß', '‚à®'. Example: '((A ‚àß ¬¨B) ‚à® C) ‚Üí D'.
- "options": An array of exactly three objects, each with "text" (string) and "correct" (boolean). Exactly one must be correct.
- "success": A short, encouraging success message (string).
- "failure": A short, lighthearted failure message (string).

Do not include any text, explanations, or markdown formatting outside of the JSON object itself.`;
            // ... (rest of fetch logic)
            const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json" } };
            let retries = 3;
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const result = await response.json();
                    const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (jsonText) return JSON.parse(jsonText);
                    else throw new Error("Invalid response structure from API.");
                } catch (error) {
                    console.error(`Attempt ${i + 1} failed:`, error);
                    if (i < retries - 1) await new Promise(res => setTimeout(res, 1000 * Math.pow(2, i)));
                    else return null;
                }
            }
        }

        function resetGame() {
            currentStageIndex = 0;
            score = 0;
            isPlayingBonus = false;
            bonusStage = null;
            scoreDisplay.textContent = `Score: ${score}`;
            startScreen.classList.remove('hidden');
            gameContainer.classList.add('hidden');
            startScreen.classList.add('fade-in');
        }
        
        function startGame() {
            score = 0;
            currentStageIndex = 0;
            isPlayingBonus = false;
            scoreDisplay.textContent = `Score: ${score}`;
            startScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            gameContainer.classList.add('fade-in');
            renderStage();
        }

        function renderStage() {
            feedbackContainerEl.classList.add('hidden');
            optionsContainerEl.style.pointerEvents = 'auto';
            optionsContainerEl.style.opacity = '1';

            let stage;
            if (isPlayingBonus) {
                stage = bonusStage;
            } else if (currentStageIndex < stages.length) {
                stage = stages[currentStageIndex];
            } else {
                stage = finalStage;
            }

            if (!stage) { resetGame(); return; }

            // Apply animations
            scenarioEl.classList.remove('fade-in');
            void scenarioEl.offsetWidth; // Trigger reflow
            scenarioEl.classList.add('fade-in');

            scenarioImageEl.textContent = stage.image;
            scenarioTextEl.textContent = stage.scenario;
            logicClueTextEl.textContent = stage.logic;
            logicClueSymbolicEl.textContent = stage.symbolic;
            
            if (stage.options && stage.options.length > 0) {
                logicClueContainerEl.classList.remove('hidden', 'fade-in');
                void logicClueContainerEl.offsetWidth;
                logicClueContainerEl.classList.add('fade-in');
            } else {
                logicClueContainerEl.classList.add('hidden');
            }

            optionsContainerEl.innerHTML = '';
            
            if (!stage.options || stage.options.length === 0) {
                // Final/Thank You Page
                isPlayingBonus = false;
                feedbackTextEl.textContent = stage.success(score);
                feedbackTextEl.classList.remove('text-red-500');
                feedbackTextEl.classList.add('text-green-500');
                feedbackContainerEl.classList.remove('hidden');
                nextButton.classList.add('hidden');
                restartButton.classList.remove('hidden');
                bonusLevelButton.classList.remove('hidden');
                restartButton.textContent = 'Play Again?';
            } else {
                 stage.options.forEach((option, index) => {
                    const button = document.createElement('button');
                    button.textContent = option.text;
                    button.className = 'w-full px-4 py-4 bg-gray-700 hover:bg-amber-500 rounded-lg shadow-md transform hover:scale-105 transition-all duration-200 slide-in-up';
                    button.style.animationDelay = `${index * 100}ms`;
                    button.onclick = () => handleOptionClick(option);
                    optionsContainerEl.appendChild(button);
                 });
            }
        }

        function handleOptionClick(option) {
            optionsContainerEl.style.pointerEvents = 'none';
            feedbackContainerEl.classList.remove('hidden');
            logicClueContainerEl.classList.add('hidden');

            const stage = isPlayingBonus ? bonusStage : stages[currentStageIndex];

            if (option.correct) {
                score += 10;
                scoreDisplay.textContent = `Score: ${score}`;
                feedbackTextEl.textContent = stage.success;
                feedbackTextEl.classList.remove('text-red-500');
                feedbackTextEl.classList.add('text-green-500');
                if (isPlayingBonus) {
                    nextButton.classList.add('hidden');
                    restartButton.classList.remove('hidden');
                    bonusLevelButton.classList.remove('hidden');
                    restartButton.textContent = 'Play From Start';
                    bonusLevelButton.textContent = '‚ú® Generate Another';
                } else {
                     nextButton.classList.remove('hidden');
                     restartButton.classList.add('hidden');
                     bonusLevelButton.classList.add('hidden');
                }
            } else {
                // Deduct points for wrong answer, but don't let score go below 0
                score = Math.max(0, score - 5);
                scoreDisplay.textContent = `Score: ${score}`;
                feedbackTextEl.textContent = stage.failure + ` (-5 points)`;
                feedbackTextEl.classList.remove('text-green-500');
                feedbackTextEl.classList.add('text-red-500');
                nextButton.classList.add('hidden');
                restartButton.classList.remove('hidden');
                bonusLevelButton.classList.add('hidden');
                restartButton.textContent = 'Try Again?';
            }
        }
        
        async function generateBonusLevel() {
            const generatedStage = await callGeminiForNewStage();
            if (generatedStage) {
                bonusStage = generatedStage;
                isPlayingBonus = true;
                renderStage();
            } else {
                // Handle generation failure
                scenarioTextEl.textContent = 'Sorry, I couldn\'t think of a new challenge right now. Please try again!';
                feedbackContainerEl.classList.remove('hidden');
                restartButton.classList.remove('hidden');
                bonusLevelButton.classList.add('hidden');
            }
        }

        // Event Listeners
        startButton.addEventListener('click', startGame);
        nextButton.addEventListener('click', () => { currentStageIndex++; renderStage(); });
        restartButton.addEventListener('click', () => {
            if (isPlayingBonus || currentStageIndex >= stages.length) {
                resetGame();
            } else {
                // If it's "Try Again" on a normal level, just re-render the same stage
                renderStage();
            }
        });
        bonusLevelButton.addEventListener('click', generateBonusLevel);
    </script>
</body>
</html>
